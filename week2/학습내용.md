# 2주차 개념 정리: JSX, State, Props ⚛️

## 1. JSX (JavaScript XML)

**JSX**는 JavaScript를 확장한 문법으로, React에서 UI가 어떻게 생겨야 하는지를 설명하기 위해 사용됩니다. HTML과 매우 비슷하게 생겼지만, 실제로는 JavaScript입니다.

### 🤔 JSX는 왜 사용할까?

- **가독성 향상**: 마크업(`HTML`)과 로직(`JavaScript`)을 하나의 파일에서 함께 작성하여 컴포넌트의 구조를 한눈에 파악하기 쉽습니다.
- **개발 편의성**: JavaScript의 모든 기능을 활용하면서 익숙한 HTML 태그 방식으로 UI를 작성할 수 있어 편리합니다.

### 📋 주요 문법 규칙

1.  **하나의 부모 요소로 감싸기**: 모든 요소는 하나의 최상위 태그(`<div>`, `<> Fragment` 등)로 감싸야 합니다.

    ```jsx
    // 잘못된 예시 ❌
    // return (
    //   <h1>안녕하세요</h1>
    //   <p>리액트입니다</p>
    // );

    // 올바른 예시 ✅
    return (
      <div>
        <h1>안녕하세요</h1>
        <p>리액트입니다</p>
      </div>
    );
    ```

2.  **JavaScript 표현식 사용**: 중괄호 `{}`를 사용하면 JSX 내부에 변수나 JavaScript 코드를 삽입할 수 있습니다.

    ```jsx
    const name = 'React';
    const element = <h1>Hello, {name}</h1>; // "Hello, React"가 됨
    ```

3.  **HTML과 다른 속성 이름**: `class`는 `className`으로, `for`는 `htmlFor`로 작성해야 합니다. JavaScript의 예약어와 충돌을 피하기 위함입니다.

    ```jsx
    const element = <div className="greeting">Hello!</div>;
    ```

4.  **인라인 스타일링**: 스타일은 객체 형태로 작성하며, CSS 속성은 카멜 케이스(camelCase)로 작성합니다.

    ```jsx
    const style = {
      backgroundColor: 'black',
      color: 'white',
      fontSize: '16px', // 숫자로만 적어도 px로 인식
    };

    const element = <div style={style}>Styled Div</div>;
    ```

---

## 2. Props (Properties)

**Props**는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때 사용하는 **읽기 전용(read-only)** 데이터입니다. 컴포넌트를 재사용 가능하게 만드는 핵심 요소입니다.

- **비유**: 함수에 전달되는 **인자(argument)**와 같습니다.

### 👨‍👩‍👧 Props 사용법

1.  **부모 컴포넌트에서 데이터 전달**: 자식 컴포넌트에 HTML 속성처럼 `prop이름="값"` 형식으로 데이터를 전달합니다.

    ```jsx
    // 부모 컴포넌트: App.js
    function App() {
      return <Greeting name="Sarah" age={25} />;
    }
    ```

2.  **자식 컴포넌트에서 데이터 받기**: 자식 컴포넌트는 함수의 매개변수로 `props` 객체를 받아 데이터를 사용합니다.

    ```jsx
    // 자식 컴포넌트: Greeting.js
    function Greeting(props) {
      return (
        <h1>
          안녕하세요, {props.name}님! {props.age}살이시군요.
        </h1>
      );
    }
    ```

### ⚠️ 중요한 특징

- **읽기 전용**: 자식 컴포넌트는 전달받은 `props`를 **절대 직접 수정해서는 안 됩니다**. 데이터 흐름은 항상 위에서 아래로(단방향) 흐릅니다.

---

## 3. State

**State**는 컴포넌트가 **내부에서 직접 관리하는 데이터**입니다. 사용자의 인터랙션 등으로 인해 **값이 변할 수 있으며**, state가 변경되면 React가 자동으로 화면을 다시 렌더링(re-rendering)합니다.

- **비유**: 컴포넌트가 사용하는 "개인 사물함"이나 "메모장"과 같습니다.

### useState 사용법

React v16.8부터는 함수형 컴포넌트에서 `useState` Hook을 사용하여 state를 관리합니다.

1.  **`useState` 불러오기**: `react` 라이브러리에서 `useState`를 import 합니다.

    ```jsx
    import React, { useState } from 'react';
    ```

2.  **State 변수 선언**: `useState(초기값)`는 배열을 반환합니다. 첫 번째 요소는 **현재 state 값**, 두 번째 요소는 **state를 업데이트하는 함수**입니다.

    ```jsx
    function Counter() {
      // count: 현재 상태 값, setCount: 상태를 업데이트하는 함수
      const [count, setCount] = useState(0); // 0은 초기값
    ```

3.  **State 사용 및 업데이트**:

    - state 값은 `count` 변수를 직접 읽어서 사용합니다.
    - state를 변경할 때는 반드시 `setCount` 함수를 사용해야 합니다. **`count = count + 1` 처럼 직접 수정하면 안 됩니다!**

    ```jsx
    // 전체 Counter 컴포넌트 예시
    function Counter() {
      const [count, setCount] = useState(0);

      const handleIncrease = () => {
        setCount(count + 1); // setCount 함수로 상태 업데이트
      };

      return (
        <div>
          <p>현재 카운트: {count}</p>
          <button onClick={handleIncrease}>+1 증가</button>
        </div>
      );
    }
    ```

## 🔄 State vs Props 비교

| 구분               | **Props**               | **State**                       |
| ------------------ | ----------------------- | ------------------------------- |
| **목적**           | 부모 → 자식 데이터 전달 | 컴포넌트 내부 데이터 관리       |
| **데이터 흐름**    | 단방향 (위에서 아래로)  | 컴포넌트 내에서 발생하고 관리됨 |
| **수정 가능 여부** | **불가능** (읽기 전용)  | **가능** (세터 함수를 통해)     |
| **소유권**         | 부모 컴포넌트           | 컴포넌트 자신                   |
